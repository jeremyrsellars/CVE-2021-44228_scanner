(ns find-class-files.program
  (:require [clojure.string :as string]
            [clojure.java.io :as io])
  (:import [java.io BufferedReader
                    Closeable
                    File
                    FileInputStream
                    FileOutputStream
                    IOException
                    InputStream
                    InputStreamReader
                    RandomAccessFile]
           [java.util ArrayList
                      Enumeration
                      HashSet
                      LinkedHashSet
                      List
                      Properties
                      Set
                      TreeSet]
           [java.util.zip ZipEntry
                          ZipException
                          ZipFile
                          ZipInputStream
                          ZipOutputStream])
  (:gen-class))

;(set! *warn-on-reflection* true)

(def ^:private is-windows? (= File/separatorChar \\))

(defn debug [& args]
  (binding [*out* *err*]
    (apply prn args)))

(defn- canonical-path
  [^File f]
  (when f
    (cond-> (.getCanonicalPath f)
      is-windows? string/upper-case)))

(defn- absolute-path
  [^File f]
  (when f
    (cond-> (.getAbsolutePath f)
      is-windows? string/upper-case)))

(defn- sym-link?
  [^File f]
  (try
    (boolean
      (and f
           (not (.contains (canonical-path f) (absolute-path f)))))
    (catch Throwable ex
      false)))  

(defn exclude-dir?
  [path]
  (let [path (str (or path ""))]
    (if is-windows?
      ; windows
      (-> path string/upper-case (.indexOf "$RECYCLE.BIN") (== 3))  

      ; linux
      (boolean
        (some?
          (fn path-is-dir-or-subdir [root-dir]
            (or (= root-dir path)
                (string/starts-with? path (str root-dir "/"))))
          ["/proc" "/sys" "/dev" "/run" "/var/run"])))))

(defn- exclude?
  [^File f {ex? :exclude? :as opts :or {ex? nil?}}]
  (ex? f))

(defn- include?
  [^File f {inc? :include? :as opts :or {inc? (constantly false)}}]
  (inc? f))

(defn- process
  [arg {proc-fn :process :as opts :or {proc-fn prn}}]
  (proc-fn arg opts))

(defn file-extension
  [f]
  (when-let [dot-ext (re-find #"\.[^\\/\.]*$" (str f))]
    (cond-> dot-ext
       is-windows? string/upper-case)))

(defn traverse-mode
  [^File f]
  (cond (nil? f)
        :nil
        
        (.isDirectory f)
        (if (sym-link? f)
           :sym-link-dir
           :directory)

        (sym-link? f)
        :sym-link-file
        
        :default
        :file))

(defmulti traverse
  (fn traverse_dispatch
    [^File f opts]
    (traverse-mode f))
  :default :default)

(defn normalize-file-extension
  [f]
  (as-> (str f) s
        (when s (file-extension f))
        (when s (string/lower-case s))))

(defmulti traverse-file
  (fn traverse-file_dispatch
    [^File f opts]
    (normalize-file-extension f))
  :default :default)

(defmethod traverse :default
  [^File fs-entry {:as opts}]
  ;(debug 'traverse :dir dir)
  (println "skipping" (str fs-entry)))

(defmethod traverse :directory
  [^File dir {:as opts}]
  ;(debug 'traverse :dir dir)
  (when-not (exclude-dir? dir)
    (doseq [^File f (.listFiles dir)]
      (traverse f opts))))

(defmethod traverse :file
  [^File file {:as opts}]
  (traverse-file file opts))

(defmethod traverse-file :default
  [^File fs-entry {:as opts}]
  ;(debug 'traverse-file :default file)
  #_(println "skipping" (str fs-entry)))

(defmethod traverse-file ".class"
  [^File file {:as opts}]
  ; (debug 'traverse-file :class file)
  (when (and (not (exclude? file opts))
             (include? file opts))
    (process [:file file] opts)))

(defn traverse-archive
  [^File file {:as opts}]
  (when (and (not (exclude? file opts)))
    (process [:archive file] opts)))

(def archive-extensions
  #{".zip"
    ".jar"
    ".ear"
    ".war"
    ".rar"})

(doseq [ext archive-extensions]
   (defmethod traverse-file ext [^File file opts](traverse-archive file opts)))

(defn get-default-roots
  []
  (if is-windows?
    [(System/getenv "SystemDrive")]
    (File/listRoots)))

(def def-opts
 {:exclude? sym-link?             ; (fn example-exclude? [^File f])
  :include? (constantly true)     ; (fn example-include? [^File f])})
  :default-roots (get-default-roots)})

(defmulti process-work
  (fn process-work_dispatch
    [[cmd-k f :as command] opts]
    cmd-k)
  :default :default)

(defmethod process-work :file
  [[cmd-k f :as command] {:keys [found-ref] :as opts}]
  (println "Found" (str f))
  (swap! found-ref conj f))

(defmethod process-work :archive
  [[cmd-k f :as command] {:keys [archive-ref] :as opts}]
  (println "Must scan" (str f))
  (swap! archive-ref conj f))

(defn found
  [file-paths {:keys [found-ref] :as opts}]
  (println "Found in archive" (string/join " -> " file-paths))
  (swap! found-ref conj file-paths))

(defn scan-nested-archive
  [file-paths, ^ZipFile zip-file, ^ZipEntry parent-entry, {:keys [errors-ref] :as opts}]
  (try
    (with-open [is (.getInputStream zip-file parent-entry)
                zis (ZipInputStream. is)]
      (loop []
        (when-let [^ZipEntry zip-entry (.getNextEntry zis)]
          (when-not (.isDirectory zip-entry)
            (let [entry-name (.getName zip-entry)
                  entry-extension (normalize-file-extension entry-name)]
               (cond (= ".class" entry-extension)
                     (when (include? (io/as-file entry-name) opts)
                       (found (conj file-paths (str zip-entry)) opts)))))

                     ; (contains? archive-extensions entry-extension)
                     ; (scan-nested-archive (conj file-paths entry-name) zip-file zip-entry opts))))
          (recur))))

    (catch Throwable ex
      (swap! errors-ref conj [:scan-nested-archive file-paths ex])
      (locking *err*
        (binding [*out* *err*]
          (prn ex))))))

(defn scan-archive
  [^File file {:keys [errors-ref] :as opts}]
  (try
    (with-open [zip-file (ZipFile. file)]
      (let [^Enumeration entriesEnumeration (.entries zip-file)]
        (loop []
          (when-let [^ZipEntry zip-entry (and (.hasMoreElements entriesEnumeration) (.nextElement entriesEnumeration))]
            (when-let [entry-name (and (not (.isDirectory zip-entry)) (.getName zip-entry))] 
              (when (include? (io/as-file entry-name) opts)
                (println "Entry of" file \: entry-name)
                (found [file (str zip-entry)] opts))
              (scan-nested-archive [file (str zip-entry)] zip-file zip-entry opts))
            (recur)))))
    (catch Throwable ex
      (swap! errors-ref conj [:scan-archive file ex])
      (locking *err*
        (binding [*out* *err*]
          (prn ex))))))

(defn include-CVE-2021-44228?
  [f]
  (boolean (or (re-find #"(?<=^|\b)JndiLookup\.class$" (str f))
               (re-find #"(?<=^|\b)log4j-core[-.0-9]*\.jar$" (str f)))))

(defn -main
  [& args]
  (let [{:as opts
         :keys [archive-ref found-ref]}
        (assoc def-opts
               :process process-work
               :parallel? false ; to-do: consider making parallel
               :include? include-CVE-2021-44228?
               :errors-ref (atom [])
               :archive-ref (atom [])
               :found-ref (atom []))
        roots (map io/as-file (if (seq args) args (:default-roots opts)))]
    
    (if (:parallel? opts)
      (pmap traverse roots (repeat opts))
      (doseq [file-or-dir roots] 
        (traverse file-or-dir opts)))

    (println "=============== archives ===============")
    (doseq [archive @archive-ref]
      (println "Must scan" (str archive)))

    (if (:parallel? opts)
      (pmap scan-archive @archive-ref (repeat opts))
      (doseq [file @archive-ref]
        (scan-archive file opts)))

    (println "=============== found    ===============")
    (doseq [found @found-ref]
      (println "Found" (if (coll? found) (string/join " :: " found) (str found))))))
