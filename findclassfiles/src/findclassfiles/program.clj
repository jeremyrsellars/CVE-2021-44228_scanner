(ns findclassfiles.program
  (:require [clojure.string :as string]
            [clojure.java.io :as io])
  (:import [java.io BufferedReader
                    Closeable
                    File
                    FileInputStream
                    FileOutputStream
                    IOException
                    InputStream
                    InputStreamReader
                    RandomAccessFile]
           [java.util ArrayList
                      Enumeration
                      HashSet
                      LinkedHashSet
                      List
                      Properties
                      Set
                      TreeSet]
           [java.util.zip ZipEntry
                          ZipException
                          ZipFile
                          ZipInputStream
                          ZipOutputStream])
  (:gen-class))

;(set! *warn-on-reflection* true)

(defn create-file-if-missing
  [f]
  (if f
    (let [f (io/as-file f)]
      (if (.exists f)
        f
        (do (spit f "") f)))))

(def ^:private is-windows? (= File/separatorChar \\))
(def ^:dynamic *debug* (boolean (System/getenv "debug")))
(def ^:dynamic *parallel* (boolean (System/getenv "parallel")))
(def ^:dynamic *log-file* (create-file-if-missing (System/getenv "log-file")))
(def ^:dynamic *report-file* (create-file-if-missing (System/getenv "report-file")))
(def output-lock *err*)

(defn debug [& args]
  (when *debug*
    (locking output-lock
      (binding [*out* *err*]
        (apply prn "Debug:" args)))))

(defn stderr [& args]
  (locking output-lock
    (binding [*out* *err*]
      (apply println args))
    (when *log-file*
      (spit
        *log-file*
        (with-out-str (apply println args))
        :append true))))

(defn stdout [& args]
  (locking output-lock
    (apply println args)
    (when *report-file*
      (spit
        *report-file*
        (with-out-str (apply println args))
        :append true))))

(defn- canonical-path
  [^File f]
  (when f
    (cond-> (.getCanonicalPath f)
      is-windows? string/upper-case)))

(defn- absolute-path
  [^File f]
  (when f
    (cond-> (.getAbsolutePath f)
      is-windows? string/upper-case)))

(defn- sym-link?
  [^File f]
  (try
    (boolean
      (and f
           (not (.contains (canonical-path f) (absolute-path f)))))
    (catch Throwable ex
      false)))  

(defn exclude-dir?
  [path]
  (let [path (str (or path ""))]
    (if is-windows?
      ; windows
      (-> path string/upper-case (.indexOf "$RECYCLE.BIN") (== 3))  

      ; linux
      (boolean
        (some?
          (fn path-is-dir-or-subdir [root-dir]
            (or (= root-dir path)
                (string/starts-with? path (str root-dir "/"))))
          ["/proc" "/sys" "/dev" "/run" "/var/run"])))))

(defn- exclude?
  [^File f {ex? :exclude? :as opts :or {ex? nil?}}]
  (ex? f))

(defn- include?
  [^File f {inc? :include? :as opts :or {inc? (constantly false)}}]
  (inc? f))

(defn- process
  [arg {proc-fn :process :as opts :or {proc-fn prn}}]
  (proc-fn arg opts))

(defn file-extension
  [f]
  (when-let [dot-ext (re-find #"\.[^\\/\.]*$" (str f))]
    (cond-> dot-ext
       is-windows? string/upper-case)))

(defn traverse-mode
  [^File f]
  (cond (nil? f)
        :nil
        
        (.isDirectory f)
        (if (sym-link? f)
           :sym-link-dir
           :directory)

        (sym-link? f)
        :sym-link-file
        
        :default
        :file))

(defmulti traverse
  (fn traverse_dispatch
    [^File f opts]
    (traverse-mode f))
  :default :default)

(defn normalize-file-extension
  [f]
  (as-> (str f) s
        (when s (file-extension f))
        (when s (string/lower-case s))))

(defmulti traverse-file
  (fn traverse-file_dispatch
    [^File f opts]
    (normalize-file-extension f))
  :default :default)

(defmethod traverse :default
  [^File fs-entry {:as opts}]
  ;(debug 'traverse :dir dir)
  (stderr "skipping" (str fs-entry)))

(defmethod traverse :directory
  [^File dir {:as opts}]
  ;(debug 'traverse :dir dir)
  (when-not (exclude-dir? dir)
    (doseq [^File f (.listFiles dir)]
      (traverse f opts))))

(defmethod traverse :file
  [^File file {:as opts}]
  (traverse-file file opts))

(defmethod traverse-file :default
  [^File fs-entry {:as opts}]
  ;(debug 'traverse-file :default file)
  #_(stderr "skipping" (str fs-entry)))

(defmethod traverse-file ".class"
  [^File file {:as opts}]
  ; (debug 'traverse-file :class file)
  (when (and (not (exclude? file opts))
             (include? file opts))
    (process [:file file] opts)))

(defn traverse-archive
  [^File file {:as opts}]
  (when (and (not (exclude? file opts)))
    (process [:archive file] opts)))

(def archive-extensions
  #{".jar"
    ".ear"
    ".war"
    ".rar"})

(doseq [ext archive-extensions]
   (defmethod traverse-file ext [^File file opts](traverse-archive file opts)))

(defn get-default-roots
  []
  (if is-windows?
    [(io/as-file (str (System/getenv "SystemDrive") "\\"))]
    (File/listRoots)))

(def def-opts
 {:exclude? sym-link?             ; (fn example-exclude? [^File f])
  :include? (constantly true)     ; (fn example-include? [^File f])})
  :default-roots (get-default-roots)})

(defmulti process-work
  (fn process-work_dispatch
    [[cmd-k f :as command] opts]
    cmd-k)
  :default :default)

(defmethod process-work :file
  [[cmd-k f :as command] {:keys [found-ref] :as opts}]
  (debug "Found" (str f))
  (swap! found-ref conj f))

(defmethod process-work :archive
  [[cmd-k f :as command] {:keys [archive-ref] :as opts}]
  ; (debug "Must scan" (str f))
  (swap! archive-ref conj f))

(defn found
  [file-paths {:keys [found-ref] :as opts}]
  (debug "Found in archive" (string/join " -> " file-paths))
  (swap! found-ref conj file-paths))

(defn scan-nested-archive
  [file-paths, ^ZipFile zip-file, ^ZipEntry parent-entry, {:keys [error-ref] :as opts}]
  (try
    (with-open [is (.getInputStream zip-file parent-entry)
                zis (ZipInputStream. is)]
      (loop []
        (when-let [^ZipEntry zip-entry (.getNextEntry zis)]
          (when-not (or (.isDirectory zip-entry) (== 0 (.getSize zip-entry)))
            (let [entry-name (.getName zip-entry)
                  entry-extension (normalize-file-extension entry-name)]
               (cond (= ".class" entry-extension)
                     (when (include? (io/as-file entry-name) opts)
                       (found (conj file-paths (str zip-entry)) opts)))))

                     ; (contains? archive-extensions entry-extension)
                     ; (scan-nested-archive (conj file-paths entry-name) zip-file zip-entry opts))))
          (recur))))

    (catch Throwable ex
      (swap! error-ref conj [:scan-nested-archive file-paths ex]))))

(defn scan-archive
  [^File file {:keys [error-ref] :as opts}]
  (try
    (when (pos? (.length file))
      (with-open [zip-file (ZipFile. file)]
        (let [^Enumeration entriesEnumeration (.entries zip-file)]
          (loop []
            (when-let [^ZipEntry zip-entry (and (.hasMoreElements entriesEnumeration) (.nextElement entriesEnumeration))]
              (when-let [entry-name (and (not (.isDirectory zip-entry)) (== 0 (.getSize zip-entry)) (.getName zip-entry))] 
                (when (include? (io/as-file entry-name) opts)
                  (debug "Entry of" file \: entry-name)
                  (found [file (str zip-entry)] opts))
                (scan-nested-archive [file (str zip-entry)] zip-file zip-entry opts))
              (recur))))))
    (catch Throwable ex
      (swap! error-ref conj [:scan-archive file ex]))))

(defn include-CVE-2021-44228?
  [f]
  (boolean (or (re-find #"(?<=^|\b)JndiLookup\.class$" (str f))
               (re-find #"(?<=^|\b)log4j-core[-.0-9]*\.jar$" (str f)))))

(defn -main
  [& args]
  (debug 'Arguments args)
  (let [{:as opts
         :keys [archive-ref found-ref error-ref]}
        (assoc def-opts
               :process process-work
               :include? include-CVE-2021-44228?
               :error-ref (atom [])
               :archive-ref (atom [])
               :found-ref (atom []))
        maybe-pmap (comp doall (if *parallel* (do (stderr "Executing in parallel.") pmap) map))
        roots (map (comp io/file canonical-path io/file absolute-path io/as-file) (if (seq args) args (:default-roots opts)))]

    (stderr "=============== [Progress] Scanning File System ===============")
    (doseq [root roots]
      (stderr (str "  " root)))

    (stderr "=============== [Progress] Finding archives (this may take a while) ===============")
    (maybe-pmap traverse roots (repeat opts))

    (stderr "=============== [Progress] Archives ===============")
    (doseq [archive @archive-ref]
      (stderr "Will scan" (str archive)))

    (stderr "=============== [Progress] Scanning Archives (this may take a while) ===============")
    (maybe-pmap
      (fn do-scan-archive [archive]
        (debug "Scanning" (str archive))
        (scan-archive archive opts))
      @archive-ref)

    (when (seq @error-ref) (stderr "=============== [Report] Errors ==============="))
    (doseq [error @error-ref]
      (stderr error))

    (stdout "=============== [Report] Found ===============")
    (doseq [found @found-ref]
      (stderr "Found" (if (coll? found) (string/join " :: " found) (str found)))
      (stdout "Found" (if (coll? found) (string/join " :: " found) (str found))))
    (stdout)

    (stdout "=============== [Report] Summary ===============")
    (stdout "This program found" (count @found-ref) "items of interest.")
    (stdout "This program encountered" (count @error-ref) "errors.")

    (System/exit (count @error-ref))
    (count @error-ref)))
